{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"CNN经典网络Lenet5","text":"前言在跟着老师学习写第一个CNN（卷积神经网络）的时候，很多地方感到困惑，对此，我决定把卷积神经网络中的经典案例进行简单的分析，这个是1998年LeCun所提出的LeNet 5，是卷积神经网络的鼻祖，也是卷积神经网络的“Hello，world”。 网络分析 Lenet 5 一共有2个卷积层，2个池化层，3个全连接层。 LeNet-5第一层：卷积层C1C1层是卷积层，形成6个特征图谱。卷积的输入区域大小是5x5，每个特征图谱内参数共享，即每个特征图谱内只使用一个共同卷积核，卷积核有5x5个连接参数加上1个偏置共26个参数。卷积区域每次滑动一个像素，这样卷积层形成的每个特征图谱大小是(32-5)/1+1=28x28。C1层共有26x6=156个训练参数，有(5x5+1)x28x28x6=122304个连接。C1层的连接结构如下所示。 LeNet-5第二层：池化层S2S2层是一个下采样层（为什么是下采样？利用图像局部相关性的原理，对图像进行子抽样，可以减少数据处理量同时保留有用信息）。C1层的6个28x28的特征图谱分别进行以2x2为单位的下抽样得到6个14x14（（28-2）/2+1）的图。每个特征图谱使用一个下抽样核。5x14x14x6=5880个连接。S2层的网络连接结构如下图 LeNet-5第三层：卷积层C3C3层是一个卷积层，卷积和和C1相同，不同的是C3的每个节点与S2中的多个图相连。C3层有16个10x10（14-5+1）的图，每个图与S2层的连接的方式如下表 所示。C3与S2中前3个图相连的卷积结构见下图.这种不对称的组合连接的方式有利于提取多种组合特征。该层有(5x5x3+1)x6 + (5x5x4 + 1) x 3 + (5x5x4 +1)x6 + (5x5x6+1)x1 = 1516个训练参数，共有1516x10x10=151600个连接。 LeNet-5第四层：池化层S4S4是一个下采样层。C3层的16个10x10的图分别进行以2x2为单位的下抽样得到16个5x5的图。5x5x5x16=2000个连接。连接的方式与S2层类似，如下所示。 LeNet-5第五层：全连接层C5C5层是一个全连接层。由于S4层的16个图的大小为5x5，与卷积核的大小相同，所以卷积后形成的图的大小为1x1。这里形成120个卷积结果。每个都与上一层的16个图相连。所以共有(5x5x16+1)x120 = 48120个参数，同样有48120个连接。C5层的网络结构如下所示。 LeNet-5第六层：全连接层F6F6层是全连接层。F6层有84个节点，对应于一个7x12的比特图，该层的训练参数和连接数都是(120 + 1)x84=10164. LeNet-5第七层：全连接层Output略 参考文献1.https://blog.csdn.net/happyorg/article/details/78274066","link":"/2020/02/14/CNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9CLenet5/"},{"title":"ResNet-18","text":"前言Deep Residual Learning for Image Recognition ResNet是何凯明（微软亚洲AI研究院工作）提出的残差神经网络，曾经在Kaggle等平台上获得多次大奖。 为什么提出ResNet众所周知，随着神经网络的发展，深度越大，网络的表达性能就越好，可实际训练的时候，随着深度的加大，网络出现了梯度弥散（也有叫梯度消失等）的情况。 比如说在原始的网络当中，输入变量每经过一层就通过一次sigmoid激活函数，由于sigmoid函数只在0附近梯度变化明显，远离0附近梯度变化趋近于0，因此随着网络的深化，梯度变化趋于0，相当于线性恒等映射，深化的网络是做了无用功。 为了解决该问题，人们想了一些办法，比如说改变激活函数使用relu，Leaky—relu，或者Batch Normalization等，但是不能从根本上解决问题，因此何凯明提出了ResNet（残差神经网络） 其他参考 虽然通过Batch Normalization或者正则初始化等能够训练了，但是又会出现另一个问题，就是退化问题，网络层数增加，但是在训练集上的准确率却饱和甚至下降了。退化问题说明了深度网络不能很简单地被很好地优化 ResNet是什么？怎么解决梯度弥散以及退化问题？两种mapping何凯明在ResNet中提出两种mapping： identity mapping(处理图像中也称叫feature map)：就是本身，即下图中的x residual mapping：指的公式中的$F(x)$ 残差函数ResNet中通过学习残差函数来解决问题，学习差值比学习梯度变化要容易的多,摘录知乎解释： F是求和前网络映射，H是从输入到求和后的网络映射。比如把5映射到5.1，那么引入残差前是F’(5)=5.1，引入残差后是H(5)=5.1, H(5)=F(5)+5, F(5)=0.1。这里的F’和F都表示网络参数映射，引入残差后的映射对输出的变化更敏感。比如s输出从5.1变到5.2，映射F’的输出增加了1/51=2%，而对于残差结构输出从5.1到5.2，映射F是从0.1到0.2，增加了100%。明显后者输出变化对权重的调整作用更大，所以效果更好。残差的思想都是去掉相同的主体部分，从而突出微小的变化，看到残差网络我第一反应就是差分放大器…（博主：哈哈，刚开始接触ResNet的时候我还没学到差分放大器） 上述中的$H(x)=F(x)+x$，$F(x)$为残差函数，如果$F(x)=0$，则为恒等映射，这样设计网络可以保证随着深度的加大，不论怎么训练，至少层数更深的网络训练的效果不会比层数浅的网络效果差，网络会一直处于最优状态(理论上)，且残差拟合更加容易，学习速度更快。 Residual Block 上图为Residual Block，可以看到输入变量x，通过两层网络和x（通过shortcut）进行element-wise add（就是对应元素加到一起，element-wise是对应元素相乘），然后再经过一个relu输出就是一个Residual Block。 这两种结构常用在ResNet18，ResNet34(左图)，ResNet50/101/152(右图)，其中右图又被称作”bottleneck” ResNet-18 Cifar-10Cifar-10这个数据集包含60000张32*32的彩色图片，这些图片一共被分成10类，有小猫，小狗等……详见：https://www.cs.toronto.edu/~kriz/cifar.html ResNet-18网络结构 上图中虚线表示channel改变，实线表示channel不变 实现代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170import torchfrom torch import nnfrom torch.nn import functional as Ffrom torch.utils.data import DataLoaderfrom torchvision import datasetsfrom torchvision import transformsfrom torch import nn, optim# from torchvision.models import resnet18class ResBlk(nn.Module): \"\"\" resnet block \"\"\" def __init__(self, ch_in, ch_out): \"\"\" :param ch_in: :param ch_out: \"\"\" super(ResBlk, self).__init__() self.conv1 = nn.Conv2d(ch_in, ch_out, kernel_size=3, stride=1, padding=1) self.bn1 = nn.BatchNorm2d(ch_out) self.conv2 = nn.Conv2d(ch_out, ch_out, kernel_size=3, stride=1, padding=1) self.bn2 = nn.BatchNorm2d(ch_out) self.extra = nn.Sequential() if ch_out != ch_in: # [b, ch_in, h, w] =&gt; [b, ch_out, h, w] self.extra = nn.Sequential( nn.Conv2d(ch_in, ch_out, kernel_size=1, stride=1),#既然维度不一样，为什么用卷积而不用别的呢？ nn.BatchNorm2d(ch_out) ) def forward(self, x): \"\"\" :param x: [b, ch, h, w] :return: \"\"\" out = F.relu(self.bn1(self.conv1(x))) out = self.bn2(self.conv2(out)) # short cut. # extra module: [b, ch_in, h, w] =&gt; [b, ch_out, h, w] # element-wise add: out = self.extra(x) + out out = F.relu(out) return outclass ResNet18(nn.Module): def __init__(self): super(ResNet18, self).__init__() self.conv1 = nn.Sequential( nn.Conv2d(3, 16, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(16) ) # followed 4 blocks # [b, 64, h, w] =&gt; [b, 128, h ,w] self.blk1 = ResBlk(16, 16) # [b, 128, h, w] =&gt; [b, 256, h, w] self.blk2 = ResBlk(16, 32) # # [b, 256, h, w] =&gt; [b, 512, h, w] # self.blk3 = ResBlk(128, 256) # # [b, 512, h, w] =&gt; [b, 1024, h, w] # self.blk4 = ResBlk(256, 512) self.outlayer = nn.Linear(32*32*32, 10) def forward(self, x): \"\"\" :param x: :return: \"\"\" x = F.relu(self.conv1(x)) # [b, 64, h, w] =&gt; [b, 1024, h, w] x = self.blk1(x) x = self.blk2(x) # x = self.blk3(x) # x = self.blk4(x) # print(x.shape) x = x.view(x.size(0), -1) x = self.outlayer(x) return xdef main(): batchsz = 32 cifar_train = datasets.CIFAR10('cifar', True, transform=transforms.Compose([ transforms.Resize((32, 32)), transforms.ToTensor() ]), download=True) cifar_train = DataLoader(cifar_train, batch_size=batchsz, shuffle=True) cifar_test = datasets.CIFAR10('cifar', False, transform=transforms.Compose([ transforms.Resize((32, 32)), transforms.ToTensor() ]), download=True) cifar_test = DataLoader(cifar_test, batch_size=batchsz, shuffle=True) x, label = iter(cifar_train).next() print('x:', x.shape, 'label:', label.shape) device = torch.device('cuda') # model = Lenet5().to(device) model = ResNet18().to(device) criteon = nn.CrossEntropyLoss().to(device) optimizer = optim.Adam(model.parameters(), lr=1e-3) print(model) for epoch in range(1000): model.train() for batchidx, (x, label) in enumerate(cifar_train): # [b, 3, 32, 32] # [b] x, label = x.to(device), label.to(device) logits = model(x) # logits: [b, 10] # label: [b] # loss: tensor scalar loss = criteon(logits, label) # backprop optimizer.zero_grad() loss.backward() optimizer.step() # print(epoch, 'loss:', loss.item()) model.eval() with torch.no_grad(): # test total_correct = 0 total_num = 0 for x, label in cifar_test: # [b, 3, 32, 32] # [b] x, label = x.to(device), label.to(device) # [b, 10] logits = model(x) # [b] pred = logits.argmax(dim=1) # [b] vs [b] =&gt; scalar tensor correct = torch.eq(pred, label).float().sum().item() total_correct += correct total_num += x.size(0) # print(correct) acc = total_correct / total_num print(epoch, 'acc:', acc)if __name__ == '__main__': main() 小结 该代码没有完整实现ResNet-18结构，只实现了两residual Block。后面我自己会补上 初学ResNet，这个代码还是很OK的。实现代码2 注：这段代码摘录于CSDN，由作者所说，acc = 95.170%，是完整实现ResNet-18，且封装性优于上述代码，参考价值很高 Pytorch上搭建ResNet-18：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970'''ResNet-18 Image classfication for cifar-10 with PyTorch Author 'Sun-qian'.'''import torchimport torch.nn as nnimport torch.nn.functional as Fclass ResidualBlock(nn.Module): def __init__(self, inchannel, outchannel, stride=1): super(ResidualBlock, self).__init__() self.left = nn.Sequential( nn.Conv2d(inchannel, outchannel, kernel_size=3, stride=stride, padding=1, bias=False), nn.BatchNorm2d(outchannel), nn.ReLU(inplace=True), nn.Conv2d(outchannel, outchannel, kernel_size=3, stride=1, padding=1, bias=False), nn.BatchNorm2d(outchannel) ) self.shortcut = nn.Sequential() if stride != 1 or inchannel != outchannel: self.shortcut = nn.Sequential( nn.Conv2d(inchannel, outchannel, kernel_size=1, stride=stride, bias=False), nn.BatchNorm2d(outchannel) ) def forward(self, x): out = self.left(x) out += self.shortcut(x) out = F.relu(out) return outclass ResNet(nn.Module): def __init__(self, ResidualBlock, num_classes=10): super(ResNet, self).__init__() self.inchannel = 64 self.conv1 = nn.Sequential( nn.Conv2d(3, 64, kernel_size=3, stride=1, padding=1, bias=False), nn.BatchNorm2d(64), nn.ReLU(), ) self.layer1 = self.make_layer(ResidualBlock, 64, 2, stride=1) self.layer2 = self.make_layer(ResidualBlock, 128, 2, stride=2) self.layer3 = self.make_layer(ResidualBlock, 256, 2, stride=2) self.layer4 = self.make_layer(ResidualBlock, 512, 2, stride=2) self.fc = nn.Linear(512, num_classes) def make_layer(self, block, channels, num_blocks, stride): strides = [stride] + [1] * (num_blocks - 1) #strides=[1,1] layers = [] for stride in strides: layers.append(block(self.inchannel, channels, stride)) self.inchannel = channels return nn.Sequential(*layers) def forward(self, x): out = self.conv1(x) out = self.layer1(out) out = self.layer2(out) out = self.layer3(out) out = self.layer4(out) out = F.avg_pool2d(out, 4) out = out.view(out.size(0), -1) out = self.fc(out) return outdef ResNet18(): return ResNet(ResidualBlock) Pytorch上训练：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import torchimport torch.nn as nnimport torch.optim as optimimport torchvisionimport torchvision.transforms as transformsimport argparsefrom resnet import ResNet18import os# 定义是否使用GPUdevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")# 参数设置,使得我们能够手动输入命令行参数，就是让风格变得和Linux命令行差不多parser = argparse.ArgumentParser(description='PyTorch CIFAR10 Training')parser.add_argument('--outf', default='./model/', help='folder to output images and model checkpoints') #输出结果保存路径args = parser.parse_args()# 超参数设置EPOCH = 135 #遍历数据集次数pre_epoch = 0 # 定义已经遍历数据集的次数BATCH_SIZE = 128 #批处理尺寸(batch_size)LR = 0.01 #学习率# 准备数据集并预处理transform_train = transforms.Compose([ transforms.RandomCrop(32, padding=4), #先四周填充0，在吧图像随机裁剪成32*32 transforms.RandomHorizontalFlip(), #图像一半的概率翻转，一半的概率不翻转 transforms.ToTensor(), transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)), #R,G,B每层的归一化用到的均值和方差])transform_test = transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),])trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform_train) #训练数据集trainloader = torch.utils.data.DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=True, num_workers=2) #生成一个个batch进行批训练，组成batch的时候顺序打乱取testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform_test)testloader = torch.utils.data.DataLoader(testset, batch_size=100, shuffle=False, num_workers=2)# Cifar-10的标签classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')# 模型定义-ResNetnet = ResNet18().to(device)# 定义损失函数和优化方式criterion = nn.CrossEntropyLoss() #损失函数为交叉熵，多用于多分类问题optimizer = optim.SGD(net.parameters(), lr=LR, momentum=0.9, weight_decay=5e-4) #优化方式为mini-batch momentum-SGD，并采用L2正则化（权重衰减）# 训练if __name__ == \"__main__\": if not os.path.exists(args.outf): os.makedirs(args.outf) best_acc = 85 #2 初始化best test accuracy print(\"Start Training, Resnet-18!\") # 定义遍历数据集的次数 with open(\"acc.txt\", \"w\") as f: with open(\"log.txt\", \"w\")as f2: for epoch in range(pre_epoch, EPOCH): print('\\nEpoch: %d' % (epoch + 1)) net.train() sum_loss = 0.0 correct = 0.0 total = 0.0 for i, data in enumerate(trainloader, 0): # 准备数据 length = len(trainloader) inputs, labels = data inputs, labels = inputs.to(device), labels.to(device) optimizer.zero_grad() # forward + backward outputs = net(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() # 每训练1个batch打印一次loss和准确率 sum_loss += loss.item() _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += predicted.eq(labels.data).cpu().sum() print('[epoch:%d, iter:%d] Loss: %.03f | Acc: %.3f%% ' % (epoch + 1, (i + 1 + epoch * length), sum_loss / (i + 1), 100. * correct / total)) f2.write('%03d %05d |Loss: %.03f | Acc: %.3f%% ' % (epoch + 1, (i + 1 + epoch * length), sum_loss / (i + 1), 100. * correct / total)) f2.write('\\n') f2.flush() # 每训练完一个epoch测试一下准确率 print(\"Waiting Test!\") with torch.no_grad(): correct = 0 total = 0 for data in testloader: net.eval() images, labels = data images, labels = images.to(device), labels.to(device) outputs = net(images) # 取得分最高的那个类 (outputs.data的索引号) _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += (predicted == labels).sum() print('测试分类准确率为：%.3f%%' % (100 * correct / total)) acc = 100. * correct / total # 将每次测试结果实时写入acc.txt文件中 print('Saving model......') torch.save(net.state_dict(), '%s/net_%03d.pth' % (args.outf, epoch + 1)) f.write(\"EPOCH=%03d,Accuracy= %.3f%%\" % (epoch + 1, acc)) f.write('\\n') f.flush() # 记录最佳测试分类准确率并写入best_acc.txt文件中 if acc &gt; best_acc: f3 = open(\"best_acc.txt\", \"w\") f3.write(\"EPOCH=%d,best_acc= %.3f%%\" % (epoch + 1, acc)) f3.close() best_acc = acc print(\"Training Finished, TotalEPOCH=%d\" % EPOCH) 实现效果 注：该图像是作者将数据下载到.txt文件，然后再matlab中进行生成 小结 将数据导入.txt文件，用matlab处理 确实是好方法，visdom用起来也会很方便 定义GPU是否使用的写法 ResNet-18模块封装性很好，完全符合结构困惑在make_layer那里最后一句的return nn.Sequential(layers)中的layers是什么意思呢，上面加*是什么意思呢？参考文献 https://blog.csdn.net/sunqiande88/article/details/80100891 http://www.jeepxie.net/article/601129.html https://www.jianshu.com/p/e58437f39f65 https://www.zhihu.com/question/53224378/answer/159102095 Cifar-10：https://www.cs.toronto.edu/~kriz/cifar.html","link":"/2020/02/27/ResNet-18/"},{"title":"Git远程管理Github仓库&遇到的问题","text":"前言一直在网络上看到很多从业好多年的后端开发人员推荐使用Git来进行代码的管理，这次在学习中简单总结一下。 git上传代码流程 $ git clone将github上download处的https地址复制，在电脑本地创建git.文件夹。 $ git add.将本地文件保存到暂存区 $ git commit -m文件提交到本地仓库 $ git push将文件上传到远程仓库 $ git pull拉取/同步远程仓库的代码到本地，每次开始开发和提交前都要记得pull一下，以免提交发生冲突。git上传遇到的问题1.The remote end hung up unexpectedly这个挺头疼的，在Stack Overflow上面找了几种方法，有人说的网络的问题，有人说是暂缓区不足，有人说是网络的问题，也有说关掉防火墙和杀毒软件会OK，还去调节参数。。。因为时间的原因，我暂时还没有试过每一种方法，目前尝试的几种方法是不成功的。git push完后会等待很长时间然后报错，/呜呜呜。。","link":"/2020/02/16/Git%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86Github%E4%BB%93%E5%BA%93&%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"ch1-1 导论","text":"为什么学？模电： 发展-&gt;高频/数电/微电子/电力电子 可直接解决工程问题：（温度……——&gt;传感器——&gt;电信号） / 数字信号——&gt;模拟电路——&gt;模拟信号 时间和幅度连续变化 学什么？电子器件 电阻：耗能元件 / 电容：储能元件（有损耗） /电感 变压器 / 受控源 /非线性器件……物理非线性器件的探索： 1904年–伦敦大学–弗莱明–发明电子管（电流电压非线性/有结构脆弱等缺点） 1947年–贝尔实验室–威廉，肖克利等三位科学家发明–晶体三极管（半导体器件） 1952年–英国皇家雷达研究所–提出”集成电路”概念 1958年–美国德州仪器公司–Jack S.Kilby–发明第一片集成电路 现代–系统集成（SOC）–&gt;集成度高课程 器件：晶体管，场效应管 放大器：顾名思义，放大小信号 且不失真 滤波器：给输入信号去除噪声 振荡器：上电即可发出脉冲（如三角波，方波，正弦波……如555振荡器） 电源：输入交流——&gt;输出稳定直流电模电难点&amp;解决方案 敏感性：器件非线性，RC数值，温度，频率（这里的频率指的是什么频率？只是输入信号吗？），噪声/干扰，电源电压…… 解决方案：1.提高器件性能 2.引入负反馈 针对负反馈，这里咱多写两句，这里和何凯明同学提出的残差网络（Resnet）很相似（其实何凯明同学也是借鉴了电路中的负反馈）只是神经网络中，他是将输出通过负反馈与前者相比较，取loss的优质带入下一层网络，而这里是将放大器倍数增大，增益只取决于F（反馈）这很有意思，但还有一些不太明白：这里F有些抽象，不明白这是怎么工作的，是什么器件来反馈 ? 重要思想……（贯彻全书？）$\\cfrac{A}{1+AF}$ $\\thickapprox$ $\\cfrac{1}{F}$ 相减和高倍放大器集成==&gt;运算放大器（operational Amplifier） 所以：运放+反馈 = …………电路 2020.2.17","link":"/2020/02/17/ch1-1%20%E5%AF%BC%E8%AE%BA/"},{"title":"ch2-1 运放基础","text":"集成运算放大器符号： 三角表示，上下端口–电源 同相输入端：输入输出信号相位相同 反相输入端：反之，相位相反 输出信号和两个输入信号之差成正比： 模型： 受控源模型 上式中的Auo–运放开环放大倍数（开环增益） 运放差模输入电压：输入端电压之差理想受控源模型 虚断路：输入电阻无限接近于0，输入部分电流也就趋近于0，所以说输入部分“虚断路” 理想运放条件：输入电阻趋近无穷大（保证全部分压给运放），输入偏流趋近0，输出电阻趋近0，开环增益趋近无穷大，上限频率趋近无穷大……传输特性集成运放电压传输特性 由于电源电压有限，所以输出电压随输入电压会有限制，输出电压和输入电压变化关系分成线性区（输入输出电压成线性关系）和限幅区。理想集成运放电压传输特性 因为Auo–&gt;无穷大，所以线性放大区———&gt;0，则同相端电压和反相端电压相等，输出电阻为0（没有电阻，只有导线，自然可视为“虚短路”），开环运放是无法作为线性放大器（开环指的是输出只受输入控制，没有反馈系统） 差模输入电压这里应该也是可以不为0，只是因为限幅，这个和趋近于0，所产生的输出电压几乎没有区别。 反相电压传输特性只是Auo &lt; 0 。传输特性图像水平翻转。 2020.2.18","link":"/2020/02/18/ch2-1%20%E8%BF%90%E6%94%BE%E5%9F%BA%E7%A1%80/"},{"title":"ch1-2 放大器主要指标","text":"什么是放大器？ 概念：功率放大倍数 大于 1 （变压器不是放大器） 同向放大器：输入输出信号相位相同 反向放大器：输入输出信号相位相反 放大器有两正负两极，作用同上，称为同向输入端和反向输入端 放大器性能指标 可等效为一个有源二端口网络（一个输入端–接信号源，一个输出端–接负载） 放大器结构是两个电阻（一个输入电阻一个输出电阻），再加上一个受控源（放大倍数） 放大器参数就是上面的放大倍数A，加上输入输出电阻阻值，以及频率响应与带宽（？？？），总谐波失真系数（非线性失真系数）THD（？？？） 放大倍数A：（也称增益）输入量和输出量的比值，电压，电流增益（无量纲 ），互阻，互导增益 输入电阻：Ri决定了放大器从电压源处分到的电压值。 输出电阻：对负载而言，放大器相当于信号源，R0是信号源内阻，则其阻值表达了其的带载能力。 频率特性:放大器中存在电容（放大器前面是输入输出电阻加上受控源，现在又有电容，所以到底放大器内部是什么结构？？）频率大，容抗小，反之，频率小，容抗就大，那么容抗会对增益有影响（怎么影响是没有说的） 放大器的截止频率和通频带：频率分低频区，中频区，高频区。频率过高或过低，增益绝对值都会下降。截止频率为0.707增益，高频区为上限截止频率，低频区为下限截止频率。两个截止频率之间为通频带。（记图像） 失真：相位失真（各波形相位不同，则叠加波形会错位，），频率失真（两个频率不同的波形叠加放大，因为频率不同，所以两个波形增益不一样，那放大后波形就会失真） 关于相位失真，好奇这个相位怎么样才能移位呢？？？ 非线性失真系数（THD）：放大器本身是非线性器件晶体管组成，所以，本身输出会产生非线性失真。有个非线性失真系数，不写了。 放大器的输出动态范围：就是避免放大器的非线性失真，不失真的电压有个范围，最大值叫做放大器的输出动态范围。 放大器传输特性：随着输入电压的变化，输出电压线性变化叫做线性输入范围，非线性临界点叫做非线性限幅。","link":"/2020/02/17/ch1-2%20%E6%94%BE%E5%A4%A7%E5%99%A8%E4%B8%BB%E8%A6%81%E6%8C%87%E6%A0%87/"},{"title":"ch2-3 相加器","text":"由运放构成的相加器传统电阻分压 缺点：1. 信号会衰减，无法放大；2. 加上负载的话，分压系数会变化；3. 两端初始的信号源也会互相干扰（可能有电场等相互干扰吧）————&gt;加上运算放大器解决问题 同相加法器 运放输入电阻趋近于无穷大，输出电阻趋近于0，起到隔离放大的作用（这里的隔离是指的隔离什么呢？？是输入信号的噪声吗？？？） 首先这里是在同相比例放大器的基础上，在输入端加入两个分开的电源以及负载（这里也要记住在脑子里），负载分别是R1和R2，输入电压为U+$$U+=\\cfrac{R2}{R1+R2}Ui1+\\cfrac{R1}{R1+R2}Ui2$$这个公式怎么推导的，这里要记住，对Ui1和Ui2分开考虑，当对Ui1考虑时，就把Ui2接地，当对Ui2考虑时就把Ui1接地，分别求出Ui1和Ui2对U+的影响，然后叠加起来即为U+处的电压$$Uo = (1+\\cfrac{Rf}{R})U+$$$$Uo = (1+\\cfrac{Rf}{R})(\\cfrac{R2}{R1+R2}Ui1+\\cfrac{R1}{R1+R2}Ui2)$$若R1 = R2$$Uo = \\cfrac{1}{2}(1+\\cfrac{Rf}{R})(Ui1 + Ui2)$$缺点：两信号源之间依然会互相影响（接在一起肯定会互相影响） 反相相加器 这里是在反相比例放大器的基础上，将反相输入端接上分别的信号源以及负载(图请记在脑子里，请记得反相输入端是虚地) 根据叠加原理，可得：$$Uo = -(\\cfrac{Rf}{R1}Ui1+\\cfrac{Rf}{R2}Ui2+\\cfrac{Rf}{R3}Ui3)$$当R1 = R2 = R3 时$$Uo = -\\cfrac{Rf}{R}(Ui1+Ui2+Ui3)$$优点：因为反相端虚地，各电流值由该支路信号源和电阻独立决定，各个信号源之间就不会影响。(这里我就奇怪了，不管是虚地还是啥的，两个连接上的信号源对这个节点就没有影响了？？？) 反相加法器的设计(记牢反相比例，同相比例放大器的闭环增益公式很重要)$$Auf = -\\cfrac{Rf}{R}$$ 实现：Uo = -6( Ui1 + Ui2 )———要求闭环输入电阻Rif大于等于30k 注：脑子里算算就行了 实现：Uo = - 5Ui1 - 8Ui2 - 3*Ui3 由于反馈网络负载是固定的，所以先确定Rf，剩下各自算算就行，脑子里过一下 同相加法器的设计(记牢反相比例，同相比例放大器的闭环增益公式很重要)$$Auf = (1 + \\cfrac{Rf}{R})$$对于同相加法器，对信号的放大倍数还取决于R1 ，R2$$Uo = (1+\\cfrac{Rf}{R})(\\cfrac{R2}{R1+R2}Ui1+\\cfrac{R1}{R1+R2}Ui2)$$ 实现：Uo = 9(Ui1 + Ui2) 对两个信号放大倍数相同，有公式可知，由于增益不变，放大倍数也不变，所以R1 = R2$$Uo = \\cfrac{1}{2}(1+\\cfrac{Rf}{R})(Ui1 + Ui2)$$剩下参数自己设一下都行 实现：Uo = 2 Ui1 + 5 Ui2同相加法器，增益不变嘛，所以放大倍数由R1 ，R2（信号源上的负载决定），所以 R1和R2求比值，剩下参数自己选择代入即可","link":"/2020/02/19/ch2-3%20%E7%9B%B8%E5%8A%A0%E5%99%A8/"},{"title":"ch2-5 积分器","text":"积分器 目标：$Uo(t)=k\\int Ui(t)dt$ 即输出与输入的积分成正比 反相积分电路 就是将反相比例放大器中的 Rf 换成电容 (A)时域分析$$Uo(t)=-Uc(t)=-\\cfrac{Q}{C}=-\\cfrac{1}{C}\\int ic(t)dt$$$$=-\\cfrac{1}{C}\\int \\cfrac{Ui(t)}{R}dt=-\\cfrac{1}{RC}\\int Ui(t)dt=-\\cfrac{1}{\\tau}\\int Ui(t)dt$$其中 $\\tau$ = RC 是积分常数 (B)频域分析 这里和反相比例放大器是一个分析方法$$Au(j\\omega)=\\cfrac{Uo(j\\omega)}{Ui(j\\omega)}=-\\cfrac{1}{j\\omega RC}=-\\cfrac{1}{j\\omega \\tau}$$因为这里有一个$\\cfrac{1}{j}=-j$ ,又是反相输入端，最外面那个负号抵消，所以： 相位滞后90度， 增益的模：$|Au(j\\omega)|=\\cfrac{1}{\\omega RC}$ 这里有个结论：频率越高，衰减越大(这里是真的不明白为什么了？？)差分积分器电路 这里和简单减法器是相似，把 Rf 和下面对应的电阻换成电容即是差分积分器啦$$Uo(j\\omega)=\\cfrac{1}{j\\omega RC}[Ui1(j\\omega)-Ui2(j\\omega)]$$$$Uo(j\\omega)=\\cfrac{1}{RC}\\int[Ui1(t)-Ui2(t)]dt$$上面一个是频域形式，一个是时域形式啦 同相积分电路 就是将反相输入端接地，Ui2 = 0$$Uo(j\\omega)=\\cfrac{1}{j\\omega RC}Ui1(j\\omega)$$$$Uo(j\\omega)=\\cfrac{1}{RC}\\int Ui1(t)dt$$ 积分器设计 这里注意一下设计积分器首先要确定时间常数 $\\tau$ ,又因为电容的可选类型比较少，电阻相对要多的多，所以，先确定电容的值，在确定电阻的阻值。 电容单位 F 换算：1F = 1 * 10^6 $\\mu$F(微法)_…………_1 $\\mu$F = 1 * 10^3 nF_…………1 $\\mu$F = 1 * 10^6 pF 单级积分器电路 由于电容是通交流隔直流的，所以只在负反馈网络加电容，会使直流无法反馈，造成积分器不正常工作，或有噪声的情况，（这里加入的电阻要保证R &gt;&gt;&gt; 10Ri）,不然对增益会很大的影响。 实验 方波转换成三角波 反相输入端输入方波，当输入为高电平，输入端高电位，输出端拉低，反馈回去，电位下降；同理反相端输入为低电平，输出端拉高电位上升，反馈回去。输出端就是三角波了。 正弦波和余弦波互相转换（因为相位互相差90度） 2020.2.20","link":"/2020/02/20/ch2-5%20%E7%A7%AF%E5%88%86%E5%99%A8/"},{"title":"ch2-4 相减器","text":"相减器目标：使输入的两个信号相减输出$$Uo = a Ui1 - b Ui2$$ 那么令同相端为被减数（Ui1），反相端为减数（Ui2），即可 $a = b + 1$ : 将Ui1和Ui2分别接地，可得到同相比例和反相比例放大器的 Uo，然后叠加原理，相加即是输出电压 推导一下： 令Ui2 接地,则为同相比例放大器$$Uo = (1 + \\cfrac{Rf}{R2})Ui1$$令Ui1接地，则为反相比例放大器$$Uo = -\\cfrac{Rf}{R2}Ui2$$用叠加定理合起来就是$$Uo = (1 + \\cfrac{Rf}{R2})Ui1 -\\cfrac{Rf}{R2}Ui2 $$ a &lt; b + 1 要减小a，减小同相输入端的电压（分压即可） 在U+处接上一个电阻，这个电阻接地即可$$Uo = (1 + \\cfrac{Rf}{R2})(\\cfrac{R4}{R1+R4})Ui1 -\\cfrac{Rf}{R2}Ui2 $$ a &gt; b + 1 同理增加a，减小Ui2的放大倍数就可以了，Rf不变，增加分母上的值即可，即，在R2上面并联一个电阻即可$$Uo = (1+\\cfrac{Rf}{R2+R})Ui1-\\cfrac{Rf}{R2}Ui2$$由于虚断的原因，在反相比例放大器的情况下，R两端电压都是0，所以R不起作用 a = b = k 常用的模型是使R2 = R1，Rf = R3 ，就可以满足 a = b = k 则：$$Uo = \\cfrac{R3}{R2}(Ui1-Ui2) = \\cfrac{Rf}{R2}(Ui1-Ui2)$$ 相减器设计实例 实现：Uo = 5 ( Ui1 - Ui2 ) 放大倍数相同，说明Rf = R4，R1 = R2，…… 实现：Uo = 5 Ui1 - 8 Ui2 写出 a &lt; b 的情况（公式） 实现：Uo = 8 Ui1 - 5 Ui2 相减器的应用 直流电平移位 案例里面是将信号接到反相输入端，同相输入端接直流信号，当然这个就反相放大了。同相放大的话就是，将信号接入同相输入端即可 抑制共模干扰 共模干扰——百度百科：共模干扰指的是干扰电压在信号线及其信号地线上的幅度相同。(额？还是觉得哪里不明白) 这里孙老师是举了例子，是把两个相同信号源的输入信号放入相减器中间，使两个相同的noise相减，抵消后输入仪器(妙极了) 简单相减器存在的问题 如果要求两个输入信号的放大倍数相同的话，那么要求上下对应的电阻阻值相同——————&gt;调节增益困难，要同步调节上下两个电阻 输入电阻偏小(注意哦，不是放大器内部的输入电阻，是同反相输入端上的电阻)，对两个信号源的影响不同(这个是为什么呢？) 仪表放大器 你好，放大器一书中把仪表放大器归于功能放大器当中哦~ 结构就是在简单的相减器的前面增加两个同相比例放大器 优点： 两个同相比例放大器由于放大器内部输入电阻阻值趋于无穷大，所以对信号输入起到了很好的隔绝作用。 通过调节两个同相比例放大器中间的电阻阻值可以很方便的改变仪表放大器的增益，为啥呢，也比较简单，我推导一下： 首先由于虚断，同相比例放大器的两个信号输入端无电流(阻值太大嘛~),由于虚端，两个信号输入端的电压相同，即信号相同，则：$$Uo1-Uo2=ix(R+R+Rx)=\\cfrac{Ui1-Ui2}{Rx}(2R+Rx)$$其中Rx是两个同相比例放大器之间的电压，Ui1和Ui2是后半部分简单减法器的输入信号端$$Uo=\\cfrac{R4}{R3}(Uo1-Uo2)=\\cfrac{R4}{R3}(1+\\cfrac{2R}{Rx}(Ui1-Ui2)$$$$Au=\\cfrac{Uo}{Ui1-Ui2}=\\cfrac{R4}{R3}(1+\\cfrac{2R}{Rx})$$所以增益可以由Rx改变啦 2020.2.20","link":"/2020/02/19/ch2-4%20%E7%9B%B8%E5%87%8F%E5%99%A8/"},{"title":"ch2-2 同相以及反相比例放大器","text":"同相比例放大器 根据理想运放传输特性，当增益Auo很大时，需要保证运放差模输入电压趋近于0，同相端输入，反相端要进行一个负反馈，使得反相端输入电压随同相端输入电压保持动态平衡，满足运放差模输入电压趋近于0。 那么为了保证运放差模输入电压趋近于0，同相端电压和反相端电压要相等（虚短路），反相端电压又等于输出端电压的分压（没有图，公式记在脑子里）带入闭环增益（输出电压比上输入的运放差模输入电压），约掉输出电压得到：$$A=\\cfrac{Uo}{Ui}=1+\\cfrac{R2}{R1}$$注意这里R2是反馈网络的负载，R1是反相输入端口的负载，要注意是，这里反相输入端口也是接地了的。(图记在脑子里啊 ) 反相比例放大器 和上面相似，同相端接地，反相端输入端。不同的是反馈端接到反相输入端，因为同相端接地，为0，反相端增加，输出电压减小，反馈给反相端口，就趋近于0.(那么这里反相输入端就可以近似看做是地，叫做虚地) 这里上课讲一个分压比，得到反相输入端的电压和运放差模输入电压以及输出电压的关系(这里不理解？？) 由所推出来的式子得到$$Uo=-\\cfrac{R2}{R1}Ui$$$$A = \\cfrac{Uo}{Ui} = -\\cfrac{R2}{R1}$$ 反相比例放大器的输入电阻 同相比例放大器的输入电阻是无穷大,反相比例放大器不是这个情况。需要考虑R2（反馈网络上的负载）对输入端的影响，通过密勒原理（不明白，感觉是电路欠下的债？？）在输入端等效出密勒等效电阻，得出密勒等效电阻趋于0（Auo在分母，趋于无穷大，结果趋于0），得出输入电阻趋于R1. 补充共模输入：大小和相位基本相同，叫做共模信号 虚短路：$Ui+ = Ui-\\not={0}$ 虚断路：$Ui+ = Ui-=0$ 2020.2.18","link":"/2020/02/18/ch2-2%20%E5%90%8C%E7%9B%B8%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%9B%B8%E6%AF%94%E4%BE%8B%E6%94%BE%E5%A4%A7%E5%99%A8/"},{"title":"ch4-10 MOS场效应管的工作原理和特性参数","text":"基本概念 绝缘栅场效应管由金属-氧化物-半导体构成(Metal-Oxide-Semiconductor),简称MOSFET(MOS管) 结构：栅极有二氧化硅(绝缘材料)和下方衬底隔开，所以栅极电流为0， MOS管类型和符号： 注:MOS管分为增强型和耗尽型，右侧竖线表示导电沟道，平时增强型MOS管导电沟道断开，而耗尽型平时导电沟道是接通的。其中箭头表示PN结的方向.N沟道表示导电沟道为N型，P沟道同上。 导通原理栅源电压Ugs对导电沟道的作用通常衬底和栅极连接，通过施加栅源电压，产生纵向的电子和空穴的移动，当形成导电沟道时的栅源电压称为开启电压，通过对栅源电压的控制可以使沟道均匀的变宽窄漏源电压Uds对导电沟道的控制作用当栅源电压大于开启电压的时候(导电沟道形成)，改变漏源电压可以使沟道不均匀变窄，直到预夹断为止(预夹断还是在电场的作用下有电流产生)增强型MOS管伏安特性曲线由于栅极无电流，所以无输入特性曲线输出特性曲线$$I_D=f(Uds)$$和结型场效应管相似，图的话看书吧转移特性$$I_D=f(Ugs)$$i和Ugs成平方性的关系 公式比较长，这里不写了，复习的话看书吧 平方率关系方程中，和沟道长宽，电子迁移速率，以及单位面积栅极电容有关系(和电容有什么关系呢?)Ugs越大，Rds越小(Ugs越大，沟道越宽，阻值自然就小了) 耗尽型MOS管伏安特性曲线由于耗尽型MOS管本身就有导电沟道，所以，有反向电压截止，其他区别不大，复习看书吧(输出特性+转移特性) 2020.3.10","link":"/2020/02/28/ch4-10%20MOS%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E7%89%B9%E6%80%A7%E5%8F%82%E6%95%B0/"},{"title":"ch2-6 微分器","text":"微分器 目标：$Uo(t)=k\\cfrac{dui(t)}{dt}$ 即输出与输入的微分成正比，微分是积分的逆运算。 微分器电路(A)时域分析 由于微分和积分是互逆的关系，所以把反相输入端的电容和反馈网络中电阻的位置互换即是，微分器电路，分析与积分器相似：$$U_o(t)=-U_R(t)=-i_R(t)R$$$$i_R(t)=i_c(t)=C\\cfrac{dUc(t)}{dt}$$$$Uo(t)=-RC\\cfrac{dUi(t)}{dt}=-\\tau \\cfrac{dUi(t)}{dt}$$(B)频域分析$$Au(j\\omega)=\\cfrac{Uo(j\\omega)}{Ui(j\\omega)}=-j\\omega RC=-j\\omega\\tau$$因为是反相输入端，抵消一个负号，所以是 j，超前90度 相位超前90度 增益的模 $|Au(j\\omega)|=\\omega RC$ 有个结论：频率越高增益越大，且有一个90度的超前相移。微分器的高频增益 由于电容是通高频，阻低频，所以，若干反相输入端有高频信号（高频噪声）输入，电容相当于是短路，高频信号会被反相放大，影响正常输出信号。 解决方法 在反相端电容的前面加一个小电阻$R_2$，要远远小于反馈网络中的负载电阻Rf阻值：$$A_u(j\\omega)=\\cfrac{U_o(j\\omega)}{U_i(j\\omega)}=-\\cfrac{R}{R_2+\\cfrac{1}{j\\omega C}}=-\\cfrac{j\\omega RC}{1+j\\omega R_2C}$$ 当$R_2$非常小的时候，可以忽略，就相当于$-j\\omega RC$ 因为高频噪声的原因，所以微分器通常在工程中会被积分器所取代，通过解微分方程就可以，举课上面的例子：$$\\cfrac{d^2U_o(t)}{dt^2}+10\\cfrac{dU_o(t)}{dt}+2U_o(t)=Ui(t)$$$$\\cfrac{dU_o(t)}{dt}=\\int[u_i(t)-10\\cfrac{dU_o(t)}{dt}-2U_o(t)]dt$$$$U_o(t)=\\iint U_i(t)dt-2\\iint U_o(t)dt-10\\int U_o(t)dt$$微分器实验 三角波方波变化 微分嘛，三角波下降的时候，斜率不变且小于0，即 $\\cfrac{U_i(t)}{dt}&lt;0$,和前面负号抵消，所以是输出高电平，同理，三角波上升时，斜率不变且大于0，即 $\\cfrac{U_i(t)}{dt}&gt;0$,前面加一个负号，所以输出低电平，最后输出的是方波。 方波变化尖脉冲 输入方波为高低电平的时候，输入电平没有变化，斜率为0，高低电平直接是突变，斜率变化很大，所以有个尖脉冲。 2020.2.21","link":"/2020/02/20/ch2-6%20%E5%BE%AE%E5%88%86%E5%99%A8/"},{"title":"ch4-11 晶体管和场效应管低频小信号模型(等效电路)","text":"前言晶体三极管模型在静态工作点附近可以近似看做线性变化，其中变化的部分看做交流分量，线性部分看做直流分量。(本章很多地方听的不明白，后期学习再补回来) 流控等效模型 Ube变化引起ib的变化体现在体现在管子的输入电阻 这里的公式下标自己觉得有点复杂，没看懂，晚上看书补充 ib对ic的控制作用体现在受控源 $i_c=\\beta i_b$ Uce对ic的影响体现在输出电阻 $rce=\\cfrac{dUce}{di_c}$ 图片PDF找一下，或者书上应该有……","link":"/2020/03/10/ch4-11%20%E6%99%B6%E4%BD%93%E7%AE%A1%E5%92%8C%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E4%BD%8E%E9%A2%91%E5%B0%8F%E4%BF%A1%E5%8F%B7%E6%A8%A1%E5%9E%8B(%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF)/"},{"title":"ch4-3 晶体二极管的特性及参数","text":"二极管的伏安特性–指数特性$$i_D=I_S(e^\\cfrac{U_D}{U_T}-1)$$ 注：其中 $I_S$ 为反向饱和电流，$U_T$为热电压，$U_D$为导通电压，$i_D$为正向导通电流 正向特性： 死区电压（门限电压）：正向加电压的过程中，一开始电流很小，然后突然指数级的增加。在电流很小的区间，电压及是死区电压。 死区电压：室温（27°C）下，硅管：0.5-0.7V，锗管：0.1-0.3V 管压降：工业上–硅管：0.7V，锗管–0.3V2. 反向特性:电流很小，硅管：一般小于0.1uA，锗管小于几十微安 二极管参数 直流电阻$$R_D=\\cfrac{U_D}{I_D}$$ 正向电阻越小，反向电阻越大，二极管的导电性能越好 交流电阻$$r_D=\\cfrac{\\Delta U_D}{\\Delta i_D}$$ $r_D &lt;&lt; R_D$ 温度特性 温度T增大:反向饱和电流增大，死区电压减小雪崩击穿电压增大（温度增加）齐纳击穿电压减小（温度减小） 最大整流电流 二极管允许通过的最大正向平均电流 最大反向工作电压 反向电流 越小越好，通常反向电流与温度密切相关 最高工作频率超过该工作频率，二极管单向导电性能变坏二级管电路模型通常看做，P端正，N端负，硅管的管压降为0.7V，锗管的管压降为0.3V即可。 2020.2.25","link":"/2020/02/25/ch4-3%20%E6%99%B6%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E7%89%B9%E6%80%A7%E5%8F%8A%E5%8F%82%E6%95%B0/"},{"title":"ch4-4 晶体二极管应用","text":"整流电路 这里最好有电路图，但是懒得加了，咱们就脑子里回忆吧，哈哈哈 二极管加负载 利用二极管单向导电性，如果输入电压大于0.7V，就输出电压=输入电压，如果输入电压小于0.7V，则二极管截止，输出电压为0. 整流桥电路(又称绝对值电路)$$U_o=|U_i|$$限幅电路 上限幅电路 双向限幅电路 当输入电压大于二极管和电压源，Uo即二极管管压降和电压源压降之和，当输入电压小于二极管和电压源，$U_o=U_i$ 2020.2.25","link":"/2020/02/25/ch4-4%20%E6%99%B6%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%BA%94%E7%94%A8/"},{"title":"ch4-1 半导体物理基础","text":"基本概念 物体分为：导体，半导体，绝缘体。其中半导体的导电能力随着温度，光照，掺杂等外界因素所改变（价带，禁带，导带） 本征半导体：纯净的硅和锗单晶体是本征半导体，硅和锗的最外层电子都是4个，则4个最外层电子又称作价电子（物理，化学性质主要取决于最外层电子）。 本征激发：价电子获得足够大的能力（即外界因素干扰），挣脱共价键的束缚，成为自由电子，产生了自由电子以及空穴，本征激发产生的空穴和自由电子的数目相等。 载流子：带负电的自由电子和带正电的空穴，都可以导电，统称为载流子。 复合：是激发的逆过程，即自由电子填入空穴，释放能量，从而消失一对载流子的过程 硅的温度温度性比锗要好，所以集成电路多用硅（因为硅的电子挣脱共价键的束缚需要的能力大于锗，硅1.21eV，锗0.78eV）N型半导体和P型半导体由于本征半导体的导电能力比较弱，掺杂一些元素的原子可以提高半导体的导电能力，杂质半导体分为N型半导体和P型半导体。 N型半导体：在本征半导体中掺入5价原子，即N型半导体。提供自由电子（称为施主电离），其中多数载流子—自由电子，少数载流子—空穴，半导体仍然保持中性（自由电子为负，原子即表示正性，抵消） 多子：多数载流子，少子–少数载流子 少子浓度和温度关系很大，多子与温度关系不大 P型半导体：在本征半导体中掺入3价原子，即P型半导体。提供空穴（称为受主电离），其中多数载流子—空穴，少数载流子—自由电子，半导体仍然保持中性（空穴显正性，原子显负，抵消）漂移电流和扩散电流 半导体电流：即自由电子形成的电流加上空穴形成的电流。 漂移电流：在电场的作用下，自由电子逆电场方向漂移，空穴顺着电场方向漂移，这样产生的电流称为漂移电流（受到载流子浓度，迁移率，电场强度的影响） 迁移率：单位电场的作用下，自由电子的移动速度比空穴快 扩散电流：半导体中浓度不均匀分布的时候，载流子会从高浓度区域向低浓度区域扩散，从而形成扩散电流，（受到载流子的浓度差或者叫浓度梯度的影响） 2020.2.24","link":"/2020/02/24/ch4-1%20%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86%E5%9F%BA%E7%A1%80/"},{"title":"ch4-7 双极型晶体管特性曲线","text":"共发射极输出特性曲线–输出电流和输出电压的关系 如上图所示，输出特性曲线分成，放大区，截止区，饱和区。 放大区 条件：e结正偏( $I_B&gt;0$ )，c结反偏（ $Uce&gt;=Ube$ ） 特点： 由图可见$I_B$对$I_C$有很强的控制力，当 $I_B$ 变化一点的时候，$I_C$就会有比较大的变化量,因此我们定义了共发射极交流电流放大倍数：$$\\beta=\\cfrac{\\Delta I_C}{\\Delta I_B}$$ 当$Uce$为常数时候，上式成立。在特性曲线上反映是两条不同的$I_B$之间的间隔 $Uce$ 对 $I_C$ 的影响很小，$I_C$略有上升，末尾不是平的，还是向上倾斜的。 原因：基区宽度调制效应，当 $Uce$ 变大后，集电区PN结的内电场变宽，所以基区变窄，基区复合的电流会少一点，但是由于 $I_B$ 不变，复合的电流很少 饱和区 条件：e结正偏，c结正偏，( Uce&lt; Ube) 即临界饱和线的左侧 特点： $I_C$不受到$I_B$的控制 $Uce$一定而$I_B$增大时，$I_C$基本不变，因此$\\beta$趋近于0 $I_B$一定时，$I_C$的数值比放大时小截止区 条件：e结和c结均处于反偏 特点： 三个电极上的电流均为反向电流，即极间开路 当$I_B=0$时，$I_C=Iceo$，小功率管$Iceo$很小，可以视$I_C=0$，当大功率管时，$Iceo$很大，则必须保证e结反偏 共发射极输入特性曲线–输入电流和输入电压的关系 随着$Uce$的增大，$I_B$也增大，类似二极管特性曲线，当$Ube&lt;0$时，晶体管截止，超过某值，e结也会反向击穿。 同样有死区电压，硅管：$Ube:$ 0.6–0.7V,锗管$Ube:$ 0.1–0.3V 转移特性（输出电流$I_C$和输入电压$Ube$的关系） 2020.2.28","link":"/2020/02/27/ch4-7%20%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF/"},{"title":"ch4-5 稳压管以及其它二极管","text":"稳压二极管 符号：在二级管的符号上加一个小弯 稳定电压（$U_Z$）：工作在反向击穿状态时的稳定电压即稳定电压 额定功耗（$P_Z$）：使用时功耗不超过这个标准，这个功耗由管子本身的属性决定 稳压电流（$I_Z$）：稳压二极管工作时候有最大电流和最小电流，在这个范围区间的就是稳压电流，小于该值，管子失去稳压作用，大于此值，管子会烧坏 $$I_Z=\\cfrac{U_Z}{I_Z}$$ 动态电阻（$r_Z$）：一般在几欧姆到十几欧姆$$r_Z=\\cfrac{\\Delta U_Z}{\\Delta I_Z}$$ 温度系数：稳定电压较高（十几伏）一般为雪崩击穿，稳定电压在6伏以下，一般为齐纳击穿，所以稳定电压一般在（5–7V）的稳压管兼有两种击穿，温度稳定性比较好 有温度补偿的稳压管：将两稳压管相互对接即可，利用一个工作在正向导通（负温度系数），一个工作在反向导通（正温度系数）即可相互补偿，改善温度稳定性。$$U=\\pm(U_Z+U_D)$$ 其中$U_D$是正向导通电压 如果计算带有稳压二极管的电路，首先要判断稳压二极管能否被击穿，方法是先假设稳压管断开，看 $U_O$ 是否大于 $U_Z$ . 具体题目翻一下MOOC，这里不记录了 稳压电路限流电阻R的选择：就是要保证电流在稳压电流区工作，公式比较长不写了，遇到具体问题再翻书补充 由稳压二极管构成的限幅电路（单向，双向）：和二极管构成的限幅电路是相似的，但是由于正向导通特性，单向限幅的时候，负端会有0.7V的电压（硅管）其他二极管 变容二极管：利用了二极管的电容特性，具体在高频时候用的比较多，遇到在做深入了解 光电二极管：被光线照射后产生一个电流 发光二极管：…… 肖特基二极管：结构是金属和N型材料掺杂，特点是速度快，常用在高频，遇到再深入了解 2020.2.26","link":"/2020/02/26/ch4-5%20%E7%A8%B3%E5%8E%8B%E7%AE%A1%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AE%83%E4%BA%8C%E6%9E%81%E7%AE%A1/"},{"title":"ch4-2 P--N结","text":"基本概念 PN结：P型半导体和N型半导体交接面处会形成一个有特殊物理性质的薄层，称为PN结 PN结的形成：由于两边载流子浓度差————&gt;多子扩散（N型半导体–自由电子，P型半导体–空穴）————&gt;交接处复合，显露出正负原子————形成内电场————&gt;阻碍多子扩散，利于少子漂移————&gt;动态平衡，形成PN结 中间形成电场的区域称为耗尽区或势垒区或阻挡区，在掺杂浓度不对称的PN结中，掺杂浓度大的地方延伸小，掺杂浓度小的地方，延伸大（因为两边正负电荷数量相等）PN结的导电特性 正向偏置：外部添加P正，N负的电场，与内电场相互抵消，耗尽层变窄，则扩散作用加强，漂移运动减弱，（也就是说N结处的自由电子向浓度低的P结移动，空穴从P向N移动），因此形成正向电流（从P——&gt;N） 注：电流方向是正电荷移动方向，与负电荷移动方向相反，因为在定义电流方向的时候，还没有发现电子…… 反向偏置：外部添加N正，P负的电场，产生与内部电场方向相同的电场，则耗尽区变宽，扩散运动减弱，漂移运动加强，反向电流很小（少子提供电流） 可以认为是（正偏—导通，反偏—截止）PN结的击穿特性 当反向电压超过反向截止电压的时候，反向电流会急剧增大，有两种机理 雪崩击穿：加反向电压，耗尽区变大，少子漂移时，被加速，动能过大，撞击共价键，使自由电子挣脱束缚，然后蝴蝶效应，一起被加速，到处撞击……反向电流变大 齐纳击穿：在重掺杂的PN结中，耗尽区很窄，所以较小的反向电压会产生很大的电场，一定的强度就可以将共价键中的价电子直接拉出，产生大量自由电子和空穴对，使反向电流急剧增大。 一般而言，对于硅材料的PN结，截止电压 &gt; 7V为雪崩击穿，截止电压 &lt; 5V为齐纳击穿；截止电压在 5 ~ 7 V时，两种击穿都有。 只要限制击穿后的电流，击穿并不损坏 PN 结（可逆性） PN结的电容特性 PN结有电容特性，由势垒电容和扩散电容两部分组成 势垒电容：高阻的耗尽区，与平板电容器相似，正偏电压越大，容值越小$$C_T=\\cfrac{\\epsilon S}{d}$$ d 是耗尽区长度，S是耗尽区横截面积 扩散电容：正向偏置的PN结，由于多子扩散，会有电容特性$$C_D=\\cfrac{\\tau I}{U_T}$$ $C_T$ 和 $C_D$ 都随外加电压的变化而变化，且都非线性，低频时可以忽略，高频时需要考虑…… 2020.2.24","link":"/2020/02/24/ch4-2%20P--N%E7%BB%93/"},{"title":"ch4-6 双极型晶体三管工作原理","text":"晶体管的结构以及符号 结构：发射区（e，emitter）集电区（c，collector），基区（b，basic） 发射区重掺杂，基区轻掺杂，集电区面积大 符号：箭头：从P区指向N区 晶体管工作原理看图比较好理解，这里我不放图了，简单叙述一下工作过程 在晶体管在发射结正偏，集电结反偏的情况下： 发射结电子因为发射结正偏，扩散运动——&gt;基区，其中少部分电子和基结的空穴复合 由于基区轻掺杂，扩散运动过来的自由电子只有少部分在基区和空穴复合 由于集电区反偏，形成强大电场，产生漂移运动，基区大部分电子漂移到集电区 因为集电区反偏，所以基区和集电区的少子相互漂移，形成反向饱和电流（很小，和温度关系很大，与之前PN结的情况是一样的） 在晶体三极管中在基区的作用下，把电子从发射区几乎全部传到了集电区，这是放大功能的体现（这哪里体现了放大？？睁眼说瞎） 比例系数 $\\beta \\alpha$ $\\overline{\\beta}$:共发射极直流电流放大系数。忽略集电区和基区的空穴和自由电子的漂移运动产生的电流（因为电流很小嘛）所以可以近似看作：$$\\overline{\\beta}=\\cfrac{I_C}{I_B}$$ 当$I_B=0$时，$I_C$中仍有电流，我们称为穿透电流（是之前忽略的一小部分来的）$$\\overline{\\beta}=\\cfrac{I_C}{I_B}$$$$I_C=\\overline{\\beta}I_B$$$$I_E=(1+\\overline{\\beta})I_B$$上式公式牢记 $\\overline{\\alpha}$:共基极直流电流放大系数。同样忽略集电区和基区的空穴和自由电子的漂移运动产生的电流，所以可以近似看作：$$\\overline{\\alpha}=\\cfrac{I_C}{I_E}$$ $\\overline{\\alpha}$和$\\overline{\\beta}$的关系$$\\overline{\\beta}=\\cfrac{\\overline{\\alpha}}{1-\\overline{\\alpha}}$$$$\\overline{\\alpha}=\\cfrac{\\overline{\\beta}}{1+\\overline{\\beta}}$$ 2020.2.26","link":"/2020/02/26/ch4-6%20%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E4%B8%89%E7%AE%A1%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"ch4-8 双极型晶体管极限参数和工作状态判别举例","text":"晶体管的极限参数 击穿电压：因为有三个极，所以有三个反向击穿电压。 集电极最大允许电流$Icm$：随着$I_C$的增大，$\\beta$会减小，当$\\beta_0=\\cfrac{2}{3}\\beta$时候的电流称作$Icm$(最大允许电流)，集电极电流超过此值的时候，放大倍数会减小(因为$\\beta$明显减小) 集电极最大允许耗散功率$Pcm$:当管子超过该功率的时候，会性能下降或者被烧坏$$P_C=I_C*Uce$$ 在上述的三个限制条件下，即是晶体三极管的安全工作区，使用管子的时候，尽量在此安全工作区下使用温度对晶体管参数的影响温度升高，$Ube$减小，$Icbo$增大，$\\beta$增大，在输出特性曲线表示为，温度升高，曲线上移的间隔变大典型题目 判断晶体管工作状态 看两极是正偏还是反偏 晶体管在放大状态下，判别管型和电机 规律：NPN管：电流从e极流出，从b,c极流入；PNP管：电流从e极流入，从b,c极流出 根据晶体管的电位判别电极，管型和材料 规律：e结电压为0.7V–硅管，0.3V–锗管；c极电位最高，e极电位最低，则为NPN管；e极电位最高，c极电位最低，则为PNP管； 2020.2.28","link":"/2020/02/27/ch4-8%20%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%E6%9E%81%E9%99%90%E5%8F%82%E6%95%B0%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81%E5%88%A4%E5%88%AB%E4%B8%BE%E4%BE%8B/"},{"title":"ch4-9 结型场效应管的工作原理和特性参数","text":"JFET基本概念 结型场效应管(Junction field effect tube —— JFET)，栅极(Grid)，漏极(Drain)，源极(Source) 结构：长方体两侧连接栅极，中间沟道连接漏极和源极 N沟道JFET：中间的沟道材料为N型材料，两侧是P型材料。符号上是G——&gt;S，箭头代表P——&gt;N(材料) P沟道JFET：中间的沟道材料为P型材料，两侧是N型材料。符号上是G&lt;——S，箭头代表P——&gt;N(材料)JFET基本控制原理$$I_D=\\cfrac{Uds}{Rds}$$$$Rds=\\rho \\cfrac{L}{S}$$ 沟道越长，阻力越大，横截面积越大，阻力越小。 PN结反偏，栅极无电流，栅极电压控制导电沟道宽度，漏极电流为多子漂移电流。比如D+，S-，电子从S——&gt;D，就是从D——&gt;S的电流了。 JFET的工作原理栅源电压对导电沟道的控制栅源电压控制中间沟道的宽窄，当沟道宽度为0时，称为( 夹断电压 ) 比如说，栅源电压反相增大，PN结变宽，那沟道就变窄了 漏源电压对导电沟道的控制当漏源电压增大会改变沟道靠近正端的宽窄(因为电压高的话，反偏程度更大一点)，当沟道在漏端被夹断的时候称为( 预夹断 ) 预夹断之后还是可以导电，因为沟道还导通大部分，在最后一小部分，尽管被夹断，但是由于电场的作用电子还是会流通。 JFET的特性曲线以共源极为例，由于PN结反偏，所以栅极输入端无电流，无输入特性曲线 输出特性$$Id=F(Uds)$$ nice啊，这张图看的很清楚 恒流区 条件：$$Ugs&gt;Ugsoff$$$$Uds&gt;=Ugs - Ugsoff$$ 就是使沟道处在预夹断状态和但没有完全夹断 特点：$Uds$增大时，$i_D$也会变大一点，因为长度变小，阻值变小，所以电流变大一点，因为增大很小所以可以看做恒流。可变电阻区 条件：$$Ugs&gt;Ugsoff$$$$Uds&lt;Ugs - Ugsoff$$ 特点 处于预夹断状态之前，Ugs增大，电流id会近似线性增大，变化的斜率受到栅源电压的控制，等效为漏极和源极直接接了一个电阻 实际上这个电阻是沟道的阻值 截止区 条件：$$Ugs&lt;=Ugsoff$$ 就是使沟道完全夹断 特点： 沟道夹断，漏极和源极之间断开 击穿区$Uds$大到一定程度就会击穿，实际中要避免这个情况转移特性$$Id=F(Ugs)$$ 和上图相似，两者成平方性的关系 2020.3.6","link":"/2020/02/28/ch4-9%20%E7%BB%93%E5%9E%8B%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E7%89%B9%E6%80%A7%E5%8F%82%E6%95%B0/"},{"title":"ch5-4 带电流负反馈的共射放大器性能分析","text":"前言在前面共射放大电路的基础上，将共射极电阻的旁路电容去电或者再加一个电阻，分析一下这个对电路的交流参数有什么影响。 对交流参数的影响$A_u$对电压放大倍数的影响$$A_u=\\cfrac{U_o}{U_i}=-\\cfrac{\\beta I_b(R_C||R_L)}{[Rbe+(1+\\beta)R_E]I_b}=-\\cfrac{\\beta I_bR_L`}{Rbe+(1+\\beta)R_E}$$ if满足$$(1+\\beta)R_E&gt;&gt;Rbe,则A_u\\approx-\\cfrac{R_L`}{R_E}$$ $R_i$输入电阻$$R_i=Rb1 || Rb2||[Rbe+(1+\\beta)R_E]$$ $R_o$输出电阻没变化，因为$R_o`&gt;&gt;R_C$,所以$R_o\\approx R_C$ 2020.3.13","link":"/2020/03/13/ch5-4%20%E5%B8%A6%E7%94%B5%E6%B5%81%E8%B4%9F%E5%8F%8D%E9%A6%88%E7%9A%84%E5%85%B1%E5%B0%84%E6%94%BE%E5%A4%A7%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"title":"ch5-1 典型放大电路结构特点-三种组态放大器电路","text":"基本放大器组成原则基本放大器通常是指的由一个晶体管或场效应管构成的单级放大电路 放大条件： 有控制元件：晶体管或者场效应管 有外加电源提供能量 偏置在放大区 待放大信号一定加在发射结(或者栅源结)，不能加到集电结(或者漏极) 信号可从集电极或者发射极输出，不可以从基极(或栅极)输出 要有负载，将变化电流转换成电压 为什么一定将待放大信号加在发射结或集电结：因为栅源电压或者Ube对输出电流的影响最大，也就是跨导比较大，所以将待放大信号加在发射结或集电结。 晶体管放大电路结构分成三类：共发射极，共集电极，共基极三种，其中最常见的就是共发射极电路 阻容耦合共发射极电路 放大过程：Ube变大——&gt;ib变大——&gt;ic=$\\beta i_b$变大——&gt;Uo变大 其中耦合电容对直流开路，使信号源和负载不影响工作点 2020.3.11","link":"/2020/03/11/ch5-1%20%E5%85%B8%E5%9E%8B%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9-%E4%B8%89%E7%A7%8D%E7%BB%84%E6%80%81%E6%94%BE%E5%A4%A7%E5%99%A8%E7%94%B5%E8%B7%AF/"},{"title":"ch5-5 共集电极放大电路分析","text":"前言就是输入电阻大，输出电阻小，适合放置在其它的部分是电路分析，公式有需要，后期再补上。 2020.3.13","link":"/2020/03/13/ch5-5%20%E5%85%B1%E9%9B%86%E7%94%B5%E6%9E%81%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/13/hello-world/"},{"title":"ch5-6 共基极放大器以及三种组态对比","text":"","link":"/2020/03/13/ch5-6%20%E5%85%B1%E5%9F%BA%E6%9E%81%E6%94%BE%E5%A4%A7%E5%99%A8%E4%BB%A5%E5%8F%8A%E4%B8%89%E7%A7%8D%E7%BB%84%E6%80%81%E5%AF%B9%E6%AF%94/"},{"title":"ch5-2 放大器的偏置电路和直流工作点的判断","text":"前言晶体管在放大应用的时候，要求外电路将晶体管偏置在放大区(若是NPN管就是发射结正偏，集电结反偏)，使得信号在放大的时候不产生线性失真(静态工作点太靠前的话工作在非线性区，就会失真) 对偏置电路的要求 在更换过管子或者温度变化之后，偏置的静态工作点也要力求稳定，即保持Icq和Uceq稳定 电路形式尽量简单，如采用单一电源，尽可能少使用电阻等 对信号和直流能量的损耗要尽量小，如减小信号中的分压分流损耗等常见偏置电路固定偏流电路没有图，自己看PDF回顾(就是一个电源，集电极($R_B$)和基极($R_C$)各添加一个电阻)，其中：$$I_C=\\beta I_B$$$$Uce=Ucc-I_C*R_C$$ 由于温度变化或者更换管子引起$\\beta$和Iceo的变化，该电路不稳定 电流负反馈型偏置电路在上面电路的基础上，在管子的发射极串联电阻即可，形成负反馈效果,可以形成自我调节 原理：Ic变大——&gt;Ie变大——&gt;Ue变大——&gt;Ube减小——&gt;Ib减小——&gt;Ic减小 $R_E$的阻值选取，自己看PDF 分压式偏置电路就是在基极的上下两侧都加上电阻，起到分压的作用，保证基极电位$U_B$固定，这样$I_C$就通过Ube对$U_E$直接产生影响，增强了Ube对$I_C$的控制 2020.3.13","link":"/2020/03/11/ch5-2%20%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E5%81%8F%E7%BD%AE%E7%94%B5%E8%B7%AF%E5%92%8C%E7%9B%B4%E6%B5%81%E5%B7%A5%E4%BD%9C%E7%82%B9%E7%9A%84%E5%88%A4%E6%96%AD/"},{"title":"icarus 美化主题的坑","text":"前言很羡慕别人做的很精美，简约大方的博客，所以自己也开始捣鼓，在Google和百度上找方法，但有些方法在自己这里不成功，下面我自己总结一下这些坑。 1.鼠标点击爱心效果看了几篇文章，都说是在/themes/icarus/sourse/js/src中添加click.js文件，然后复制代码，实际上没有最后的src文件，在/themes/icarus/sourse/js里添加即可。","link":"/2020/02/15/icarus%20%E7%BE%8E%E5%8C%96%E4%B8%BB%E9%A2%98%E7%9A%84%E5%9D%91/"},{"title":"visdom--Pytorch可视化工具","text":"前言从安装visdom到我现在写这篇博客已经有至少半个月了吧，实际上使用visdom的次数可能也就2，3次，上次使用visdom是学习MNSIT的时候，这次学习迁移学习-自定义数据集操作的时候，再一次用到，我一下子也想不起来，但是数据可视化十分重要，包括数据和模型的调试，科研论文的撰写，这都是离不开的，所以这里就做一个简单的总结 什么是可视化工具这里的可视化就是将，data中的数据，比如说image，或者学习参数，test_acc等用图表等形式显示出来。 现在TensorFlow用的是TensorBoard，对应的pytorch有一个TensorBoardX，和visdom，两个都是可视化工具，但是有所不同，TensorBoardX在绘制图像等时会产生文件夹，如果数据很大，就会存储大量的文件，导致运行很卡；另外，在代码方面TensorBoardX不能直接支持tensor变量，需要再代码中将其转换成numpy数据类型，绘制图像帧数在30s更新一次。 相比较而言，visdom不会产生文件夹，而且可以直接支持Tensor变量，当然最后绘制图像都是使用的numpy数据类型，但是visdom在内部进行了Tensor——&gt;numpy数据类型的一个转换，因此在代码里可以省去变量类型转换的步骤，最重要的是visdom的数据更新速度是5s更新一次数据点。 visdom的安装这里主要参考网易云课堂上龙龙老师的讲解，但是实际安装时遇到了一些别的困难，导致，没有办法像视频演示一样安装，网上查询资料说是可能因为pip 安装源来自于墙外网站，所以部分下载文件被过滤(删除)了，然后我科学上网以后，下载完毕还是一样的缺失文件，在网络上大部分是Linux的操作，对于Windows的解决方法如下： 在CSDN上下载一个static文件(淘宝1.2)，里面有别人下载好的json等文件，将原来文件中static替换掉即可成功运行。 visdom的使用打开cmd或者git bash(终端)，输入： -m visdom.server 注：上面窗口不要关掉，后台继续运行可以得到一个浏览器地址，将该地址在浏览器中打开即可 visdom语法123456789101112131415161718from visdom import Visdomviz = visdom()viz.line([0.], [0.], win='train_loss', opts=dict(title='train loss')) #新建一个窗口(图像)，初始化变量，第一个[0.]是Y，第二个[0.]是X，其中win是Window的缩写，title是图像的名字viz.line([[0.0, 0.0]], [0.], win='test', opts=dict(title='test loss&amp;acc.', legend=['loss', 'acc.']))#新建一个窗口(图像)，两个变量，第一个[0.0，0.0]代表两个Y变量，第二个[0.]代表Xviz.line([[test_loss, correct / len(test_loader.dataset)]],[global_step], win='test', update='append')#初始化完毕，就带入变量，其中update='append'指的是数据实时更新viz.images(data.view(-1, 1, 28, 28), win='x')#载入MNSIT的图片viz.text(str(pred.detach().cpu().numpy()), win='pred',opts=dict(title='pred'))#载入MNSIT的predict数字，最终网络根据图片预测出来的数字。 总结上面代码中列举了几个最简单的，绘制曲线，载入图片，text文案的方法，以后如果又忘记了，就有可以复习的资料了，加油~","link":"/2020/03/15/visdom--Pytorch%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/"},{"title":"如何在AD18新建工程","text":"前言在2020年一月份学的AD18，过了两个月重新上手画板子，真的是忘的一干二净了，雕刻机的操作步骤也忘记了，方便雕刻，好像板子要反着画？？到时候是又要请教春哥和钱哥了，先来总结一下AD18新建工程的步骤。 新建步骤 先在需要的地方新建文件夹，重命名 打开AD18，点击文件，新的，项目，(使用默认模式Default)选择好新建路径，创建，ok 然后右击左栏产生的new Project，分别创建新的原理图，PCB，元件库，封装库即可 2020.3.13","link":"/2020/03/13/%E5%A6%82%E4%BD%95%E5%9C%A8AD18%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/"},{"title":"ch5-3 共射放大器性能分析","text":"前言之前晚上做练习的时候(就是黄老师慕课堂上网课)，有的题目实在看不明白，也不知道同学们都是咋写出来的？所以没有提交，这回mooc上面看过网课了，才明白，这里总结一下 分析步骤这个分析方法的全称：共射极放大器的交流等效电路分析法 画出直流通路，估算直流静态参数 画直流通路就是，电容开路，交流电源短路，直流静态参数：$I_B I_C Ube Uce$ 在直流通路的基础上画出交流通路，估算交流参数 画交流通路，就是电容短路，直流电源接地，为什么接地呢，因为对于交流信号而言，直流信号是平的(不考虑噪声，理论上是这样的)，交流分量就是0，所以和接地没有区别，所以就一起接地啦。交流参数：$A_u A_i R_i R_o Aus$ 交流参数说明 $A_u$ :电压放大倍数，怎么求记在脑子里 $A_i$:电流放大倍数，由于前后电阻都很大，所以可以看做微变等效模型前后电流之比，近似$\\beta$ $R_i$:输入电阻,输入的几个电阻并联就可以了 这里说明一下由于一般来说，Rb&gt;&gt;Rbe,所以，Rbe近似Ri，在微变等效模型中$Rbe=R`+(1+\\beta)\\cfrac{26mV}{I_CmA}$,所以$\\beta$ 越大，输入电阻越大 $R_o$:输出电阻，负载电阻不算，往里看，剩下电阻并联即可，因为Rce比较大，所以输出电阻$R_o近似=R_C$ $Aus$:源电压放大倍数，就是输出电压和信号源电压的比值，注意信号源电压和输入电压的区别是，输入电压在信号源上的内阻分压了。分压求解即可 2020.3.13","link":"/2020/03/13/ch5-3%20%E5%85%B1%E5%B0%84%E6%94%BE%E5%A4%A7%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"title":"电机选型以及驱动电路","text":"前言智能车制作新手上路，现在开始准备画整车的电路板，电路板一般分成4个模块：电源部分，驱动部分，主控部分，信号部分，这篇文章简单总结一下电机的选择和对应驱动电路的选择 电机电机分类：无刷电机和有刷电机，相对而言，无刷电机更好，它没有损耗，而且支持静音，那么有刷电机就会有损耗，寿命有限，且会有声音。无刷电机的缺点是比较贵，少则几百，多则上千，那么有刷电机价格则从十几到几百不等。 其中无刷电机又分为带霍尔元件和不带霍尔元件两种，霍尔元件的作用是测速，不带霍尔元件测速的话需要测量电机产生的反电动势，通常电机的转速都在几万转每秒，所以智能车转速需求较小，采用带霍尔测速好，对于无人机等需要高转速的应用，高转速会产生较大的反电动势，更容易测量，所以适合不带霍尔元件的无刷电机 减速箱由于电机每秒转速通常上万，智能车电机不需要这么大的转速，所以一般会在电机上加减速箱，同时减速箱也有增加扭矩的功能 扭矩的测量通常测量方法是测量电机的抖转电流和空载电流(主要是测抖转电流)，空载电流是电机不带负载的工作电流，抖转电流是电机被动停转时的工作电流，那么抖转电流越大，说明电机的带载能力越强 测量方法是给电机加上轮子，通电开始转动，然后将轮子捏住，使其不转动，然后测量电机的电流 驱动电路理论上，有刷电机的两端接上单片机的两个引脚，一端接3.3V，一端接0V，电机就可以动了，但是实际上不可能，因为单片机提供电流太小了，通常单片机的引脚电流不超过20mA，而小电机的驱动电流都多达160mA左右，所以需要再单片机和电机之间添加驱动电路 H桥电路和集成芯片最常见的驱动电路就是H桥电路了，由二极管组成(不贴图了，感兴趣且忘记了的话，自己再网上再搜一搜)，很麻烦，而且可以加载十几A的电流，我们小车用不到这么多，所以可以使用集成芯片，在芯片的周围会添加一些电容和电阻，所有方案可以在淘宝上参考产品级别的模块原理图或者是智能车的技术手册 这里有几个小技巧： 在单片机的引脚输入端上加300Ω(这个阻值是经验值)的电阻，目的是保护电路。 在单片机的两个引脚输入端分别下拉电阻，也是保证在每有接到单片机引脚高电平的时候，一直强制要求两个输入端保持低电平 在电机的两个输入端口接上电容，起到滤波的作用 2020.3.12","link":"/2020/03/12/%E7%94%B5%E6%9C%BA%E9%80%89%E5%9E%8B%E4%BB%A5%E5%8F%8A%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF/"},{"title":"生不逢时—曾国藩","text":"前言寒假时间转瞬即逝，为数不多的收获之一是在受到白岩松的启发后，将《曾国藩》全书（一共上中下三册）看完，略有启发，这里记录下来。 正文本书讲诉曾国藩年轻气盛之时，历经回乡守孝，出山创建湘军，官场不顺，三败石达开，至攻克江宁（九弟-曾国荃），平定太平天国，整饬两江，被迫与捻军作战不利，到处理天津教案名声败北，最后开始新办洋务，送幼童出国学习技术，最后在矛盾与怅然中离去。 时代所限的“晚清名臣”曾国藩在晚年多次提及天命，用了比喻，与康福提到，自己和皇上都是棋盘中的棋子，那谁是执子人呢，曾国藩答：天命。这里的天命是什么，是时代命运，清朝末年，妇人垂帘，皇子孱弱，国运衰微，到了什么地步呢，堂堂江宁，汉唐繁盛至极，现今竟然城内屋檐下，饿殍，乞丐随处可见，比起太平天国时期，竟然是比之远远不如，皇室中，恭亲王和西宫太后内斗，内忧外患，西方列强制度先进，技术先进，压迫清政府。用李鸿章的话是“三千年之未有大变局”。 曾国藩从小受到程朱理学理学，孔孟熏陶，心中把忠于皇室作为立人为本的标杆，自创湘军，希望也是帮助君主，使天下太平，百姓过上好日子，心只是可惜，天命不从，若是汉唐鼎盛时代，曾国藩一定可有所为，流芳百世，可惜时代变化，恰恰是忠于皇室，忠于国运衰微的皇室让他走上了一条错误的道路。 曾国藩在晚年的时候心病严重，一心希望世间太平，让人民过上好日子，可事与愿违，街头百姓无饭可吃，山头绿林强盗与官府打为一片，官僚腐败彻底，细细一想，自己用了十几年的生涯创立湘军，最后攻下江宁，平定太平天国，又是为了什么呢。书中说曾国藩晚年在与郭嵩焘的交谈中，郭嵩焘大力批评曾国藩居于忠于皇室的“小节”，而不顾民族和中华命运的“大节”，不知道是不是真的有这次交谈，但是相信若有机会与曾国藩对话，这也是作者心中想表达出来的意思吧。 曾国藩也只是时代轮换下的一个可怜人了。 李鸿章是曾国藩的弟子，在书中，曾国藩知道自己时日不多，在晚年与所有健在的人，一一作了告别，包括他最得意的弟子——李鸿章，此后书中再无李鸿章出现，我感兴趣的是李鸿章是怎么想的呢，众人熟知的是李鸿章也是晚清四大名臣之一，被称作是“中国的俾斯麦”，在曾国藩去世之后，本书已经结束，但历史没有，李鸿章一直作为晚清的执掌大臣，签署了各个辱国条约，李鸿章又是怎样的心理变化呢，还有军事天才，左宗棠，他在面临外忧内患的情况下又做了什么，，思考了什么呢，历史的趣味大概就在这里了。","link":"/2020/02/20/%E7%94%9F%E4%B8%8D%E9%80%A2%E6%97%B6%E2%80%94%E6%9B%BE%E5%9B%BD%E8%97%A9/"},{"title":"hexo 操作注意","text":"前言本文针对自己使用hexo中遇到的问题进行总结 1 instal安装超时，ERROR这个用国内的淘宝镜像源进行安装，在安装过cnpm基础之上，每次将命令中的npm修改成cnpm即可。 2 hexo d ERRORhexo d命令报错 ERROR Deployer not found：git这个是因为没有安装hexo-deployer-git插件，安装即可，命令如下： 1npm install hexo-deployer-git --save 3 hexo 常用指令hexo g ：generate 重新生成改动文件hexo clean ：清除缓存文件和已经生成的静态文件（在更换主题时需要）hexo s：server （也可以理解start）启动本地服务器hexo d：deploy 部署网站（上传远程仓库） 4 hexo d ERROR Timeout上传失败，发现是网络问题，发现如果科学上网的话是没有出现过ERROR Timeout的情况","link":"/2020/02/15/hexo%20%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F/"},{"title":"电解电容与滤波电容","text":"前言今天在研究电源部分的降压模块，其中的线性电源模块(TPS768xx)输入端接了两个电容，一个普通电解电容，一个是滤波电容，那么有两个问题产生了：为什么要接两个电容滤波呢，一个不够么？电解电容和滤波电容的区别？ 电解电容和滤波电容的区别以及滤波工作原理首先，电解电容和滤波电容一样也具有滤波的作用，不过他们的用处和材料有所不同，同为滤波，工作原理很简单，电容是起到一个充电再放电的过程，电容作为电能的储存容器和储水容器一样，当有水流入的时候就把阀门打开，存储水量，到存储上限了以后再放出来，这其中把水放入和将水放出都需要一定的时间。因此在通过电容以后，电压是无法突变的！因此电容实际上是对电压做了一次平滑处理。 为什么接两个电容滤波呢原因很简单，因为不同容值的电容对不同频率的纹波(噪声)进行滤波，一般0.1uf是高频滤波，可以提高芯片的高频性能，10uf是一般滤波。一般都是一个大容量的电容和小容量的电容并联接在输入端口，可以起到一般滤波加上高频滤波的作用。 在百度百科上查阅有搭配是大电容(1000uf),小电容(0.01uf)，在用TPS786xx时(线性电源降压模块)，数据手册上建议是大电容(10uf)，小电容(0.1uf) 为什么会有高频噪声呢 当刚开始上电的时候会有负载瞬态响应，电流很大，响应很大，会产生高频噪声 此外，在高功耗电路上，尤其是电源模块，其中的功率线(有大电流通过的线，不是信号线)上，由于输出功率的变化，会导致电源电压不稳定，从而产生自激现象，产生部分高频噪声 2020.3.13","link":"/2020/03/12/%E7%94%B5%E8%A7%A3%E7%94%B5%E5%AE%B9%E4%B8%8E%E6%BB%A4%E6%B3%A2%E7%94%B5%E5%AE%B9/"}],"tags":[],"categories":[{"name":"machine learning","slug":"machine-learning","link":"/categories/machine-learning/"},{"name":"模电笔记","slug":"模电笔记","link":"/categories/%E6%A8%A1%E7%94%B5%E7%AC%94%E8%AE%B0/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"NXP智能车","slug":"NXP智能车","link":"/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"},{"name":"生活感想","slug":"生活感想","link":"/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%83%B3/"}]}